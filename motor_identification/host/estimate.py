import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import savgol_filter
from scipy import stats
import json

# --- Configuration ---
INPUT_FILENAME = 'experiment_data.csv'
OUTPUT_MODEL_FILE = 'model_parameters.json'

# --- Hardcoded Physics Constants ---
# Shape: Ring (Thick-walled cylinder)
MASS = 0.09          # kg
RADIUS_INNER = 0.05  # meters
RADIUS_OUTER = 0.06  # meters

def main():
    print("--- Motor Parameter Estimator ---")

    # 1. Read experiment data
    try:
        print(f"Reading data from {INPUT_FILENAME}...")
        df = pd.read_csv(INPUT_FILENAME)
    except FileNotFoundError:
        print(f"Error: Could not find {INPUT_FILENAME}. Run experiment.py first.")
        return

    # Check columns
    required_cols = ['Time(s)', 'Input', 'Angle']
    if not all(col in df.columns for col in required_cols):
        print(f"Error: CSV missing columns. Found: {df.columns}. Expected: {required_cols}")
        return

    # 2. Clean data & Compute Derivatives
    print("Processing data...")
    dt = df['Time(s)'].diff().mean()
    
    # Savitzky-Golay filter settings
    window_length = 11 
    poly_order = 3

    df['Velocity'] = savgol_filter(df['Angle'], window_length, poly_order, deriv=1, delta=dt)
    df['Acceleration'] = savgol_filter(df['Angle'], window_length, poly_order, deriv=2, delta=dt)

    # 3. Physics Calculation
    print(f"Load Properties: Ring (Mass={MASS}kg, R_in={RADIUS_INNER}m, R_out={RADIUS_OUTER}m)")
    
    # Inertia for thick-walled ring
    inertia = 0.5 * MASS * (RADIUS_INNER**2 + RADIUS_OUTER**2)
    print(f"Calculated Moment of Inertia (I): {inertia:.6e} kg*m^2")

    df['Estimated_Torque'] = inertia * df['Acceleration']

    # 4. Estimate Transfer Function
    slope, intercept, r_value, p_value, std_err = stats.linregress(df['Input'], df['Estimated_Torque'])
    
    transfer_function_str = f"Torque(N*m) = {slope:.4f} * Input_Signal + {intercept:.4f}"
    
    print("\n--- Results ---")
    print(f"Transfer Function: {transfer_function_str}")
    print(f"Correlation (R^2): {r_value**2:.4f}") # type: ignore

    # 5. Save Model to JSON
    model_data = {
        "slope": slope,
        "intercept": intercept,
        "inertia": inertia,
        "mass": MASS,
        "note": "Generated by estimate.py"
    }
    
    try:
        with open(OUTPUT_MODEL_FILE, 'w') as f:
            json.dump(model_data, f, indent=4)
        print(f"\n[SUCCESS] Model parameters saved to '{OUTPUT_MODEL_FILE}'.")
        print("You can now run validate.py without manual input.")
    except Exception as e:
        print(f"Error saving model file: {e}")

    # 6. Plotting
    print("Plotting results...")
    fig, axs = plt.subplots(4, 1, figsize=(10, 12), sharex=True)
    
    axs[0].plot(df['Time(s)'], df['Input'], color='tab:blue')
    axs[0].set_ylabel('Input Signal')
    axs[0].set_title(f'System Response Analysis\n{transfer_function_str}')
    axs[0].grid(True, alpha=0.5)

    axs[1].plot(df['Time(s)'], df['Angle'], color='tab:orange')
    axs[1].set_ylabel('Position (Angle)')
    axs[1].grid(True, alpha=0.5)

    axs[2].plot(df['Time(s)'], df['Velocity'], color='tab:green')
    axs[2].set_ylabel('Velocity (rad/s)')
    axs[2].grid(True, alpha=0.5)

    axs[3].plot(df['Time(s)'], df['Acceleration'], color='tab:red')
    axs[3].set_ylabel('Acceleration (rad/s^2)')
    axs[3].set_xlabel('Time (s)')
    axs[3].grid(True, alpha=0.5)
    
    plt.tight_layout()
    plt.savefig('estimation_results.png')
    print("Plot saved to 'estimation_results.png'. Displaying...")
    plt.show()

if __name__ == "__main__":
    main()